#include <WiFi.h>
#include <WebServer.h>
#include <ArduinoJson.h>
#include "HX711.h"

// =====================
// WLAN VERBINDUNG
// =====================
const char* ssid = "Kaffeemuehle";
const char* password = "12345678";

// =====================
// HARDWARE PINS
// =====================
HX711 scale;
#define DT_PIN 4
#define SCK_PIN 5
#define OPTO_PIN 11     // Steuert PC817 Optokoppler
#define TARE_BTN 12

// =====================
// WEB SERVER
// =====================
WebServer server(80);

// =====================
// VARIABLEN
// =====================
float currentWeight = 0;
float targetWeight = 18.0;
int targetGrindLevel = 5;
bool isGrinding = false;
bool scaleOK = false;
String lastAction = "System gestartet";
unsigned long grindStartTime = 0;
const unsigned long MAX_GRIND_TIME = 45000;
bool manualStopRequested = false;
bool waitForStartSignal = false;  // NEU: Wartet auf Start-Befehl

// =====================
// KALIBRIERUNG
// =====================
float calibrationFactor = 1038;

// =====================
// FUNKTIONEN
// =====================

bool initScale() {
  Serial.print("Initialisiere W√§gezelle... ");
  
  scale.begin(DT_PIN, SCK_PIN);
  
  if(scale.wait_ready_timeout(3000)) {
    scale.set_scale(calibrationFactor);
    scale.tare();
    delay(300);
    
    float test = scale.get_units(3);
    if(abs(test) < 1000) {
      Serial.println("OK");
      Serial.print("Test: ");
      Serial.print(test, 1);
      Serial.println(" g");
      return true;
    }
  }
  
  Serial.println("FEHLER");
  return false;
}

void readScale() {
  static unsigned long lastRead = 0;
  unsigned long now = millis();
  
  if(now - lastRead > 100) {
    if(scaleOK && scale.is_ready()) {
      currentWeight = scale.get_units(1);
      if(currentWeight < 0) currentWeight = 0;
    }
    lastRead = now;
  }
}

// =====================
// PC817 OPTOKOPPLER-STEUERUNG
// =====================
void setOptocoupler(bool state) {
  if(state) {
    // Optokoppler EIN = Maschine START
    digitalWrite(OPTO_PIN, HIGH);
    Serial.println("üîµ PC817: AKTIV (Pin HIGH)");
    Serial.println("   ‚Üí Maschine STARTET");
  } else {
    // Optokoppler AUS = Maschine STOP
    digitalWrite(OPTO_PIN, LOW);
    Serial.println("‚ö™ PC817: INAKTIV (Pin LOW)");
    Serial.println("   ‚Üí Maschine STOPPT");
  }
}

// NEUE FUNKTION: Startet Mahlung mit gespeicherten Werten
void startGrindingNow() {
  if(isGrinding) {
    lastAction = "Bereits am Mahlen";
    Serial.println("‚ö†Ô∏è Bereits am Mahlen!");
    return;
  }
  
  isGrinding = true;
  manualStopRequested = false;
  grindStartTime = millis();
  waitForStartSignal = false;
  
  // PC817 aktivieren (Maschine starten)
  setOptocoupler(true);
  
  lastAction = "Gestartet: " + String(targetWeight, 1) + "g (Mahlgrad " + String(targetGrindLevel) + ")";
  
  Serial.println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Serial.println("   üöÄ MAHLUNG GESTARTET");
  Serial.println("   Ziel: " + String(targetWeight, 1) + "g");
  Serial.println("   Mahlgrad: " + String(targetGrindLevel));
  Serial.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
}

// Alte Funktion (f√ºr Kompatibilit√§t)
void startGrinding(float weight, int grindLevel) {
  targetWeight = weight;
  targetGrindLevel = grindLevel;
  startGrindingNow();
}

void stopGrinding() {
  if(isGrinding) {
    isGrinding = false;
    manualStopRequested = true;
    waitForStartSignal = false;
    
    // PC817 deaktivieren (Maschine stoppen)
    setOptocoupler(false);
    
    unsigned long grindTime = (millis() - grindStartTime) / 1000;
    lastAction = "Gestoppt nach " + String(grindTime) + "s";
    
    Serial.println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    Serial.println("   üõë MAHLUNG GESTOPPT");
    Serial.println("   Gemahlen: " + String(currentWeight, 1) + "g von " + String(targetWeight, 1) + "g");
    Serial.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  }
}

void checkGrinding() {
  if(!isGrinding) return;
  
  // Pr√ºfe auf Zielgewicht
  if(!manualStopRequested && currentWeight >= targetWeight) {
    isGrinding = false;
    setOptocoupler(false);
    
    unsigned long grindTime = (millis() - grindStartTime) / 1000;
    lastAction = "Fertig: " + String(currentWeight, 1) + "g nach " + String(grindTime) + "s";
    
    Serial.println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    Serial.println("   ‚úÖ MAHLUNG ABGESCHLOSSEN");
    Serial.println("   Erreicht: " + String(currentWeight, 1) + "g");
    Serial.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    return;
  }
  
  // Timeout pr√ºfen
  if(millis() - grindStartTime > MAX_GRIND_TIME) {
    isGrinding = false;
    setOptocoupler(false);
    lastAction = "TIMEOUT nach " + String(MAX_GRIND_TIME/1000) + "s";
    Serial.println("‚ö†Ô∏è MAHLUNG TIMEOUT");
  }
}

// =====================
// API ENDPOINTS (ANGEPASST)
// =====================

void handleGrind() {
  // Wird von ESP32 #2 aufgerufen, wenn direkt gestartet werden soll
  if(server.hasArg("weight") && server.hasArg("level")) {
    float weight = server.arg("weight").toFloat();
    int level = server.arg("level").toInt();
    
    if(weight > 0 && weight <= 100 && level >= 1 && level <= 10) {
      startGrinding(weight, level);
      server.send(200, "application/json", "{\"success\":true,\"message\":\"Mahlung gestartet\",\"targetWeight\":" + String(weight,1) + "}");
    } else {
      server.send(400, "application/json", "{\"success\":false,\"message\":\"Ung√ºltige Parameter\"}");
    }
  } else {
    server.send(400, "application/json", "{\"success\":false,\"message\":\"Parameter fehlen\"}");
  }
}

void handleStart() {
  // NEU: Startet sofort mit den bereits gesetzten Werten
  // Wird von ESP32 #2 aufgerufen, nachdem Mahlgrad eingestellt wurde
  if(!isGrinding) {
    startGrindingNow();
    server.send(200, "application/json", "{\"success\":true,\"message\":\"Mahlung gestartet\",\"targetWeight\":" + String(targetWeight,1) + "}");
  } else {
    server.send(200, "application/json", "{\"success\":false,\"message\":\"Bereits am Mahlen\"}");
  }
}

void handleStop() {
  stopGrinding();
  server.send(200, "application/json", "{\"success\":true,\"message\":\"Mahlung gestoppt\"}");
}

void handleTare() {
  if(scaleOK) {
    scale.tare();
    currentWeight = 0;
    lastAction = "Tariert";
    server.send(200, "application/json", "{\"success\":true,\"message\":\"Getariert\"}");
  } else {
    server.send(500, "application/json", "{\"success\":false,\"message\":\"W√§gezelle nicht initialisiert\"}");
  }
}

void handleSetTarget() {
  // NEU WICHTIG: Setzt nur das Ziel, startet NICHT
  // Wird von ESP32 #2 aufgerufen, wenn Rezept gew√§hlt wird
  if(server.hasArg("weight")) {
    targetWeight = server.arg("weight").toFloat();
    if(server.hasArg("level")) {
      targetGrindLevel = server.arg("level").toInt();
    }
    lastAction = "Ziel gesetzt: " + String(targetWeight, 1) + "g (Mahlgrad " + String(targetGrindLevel) + ")";
    
    // Signalisiert dass wir auf Start warten
    waitForStartSignal = true;
    
    server.send(200, "application/json", "{\"success\":true,\"message\":\"Zielgewicht gesetzt\",\"targetWeight\":" + String(targetWeight,1) + ",\"grindLevel\":" + String(targetGrindLevel) + "}");
  } else {
    server.send(400, "application/json", "{\"success\":false,\"message\":\"Gewicht nicht angegeben\"}");
  }
}

void handleStatus() {
  StaticJsonDocument<512> doc;
  doc["weight"] = currentWeight;
  doc["grinding"] = isGrinding;
  doc["targetWeight"] = targetWeight;
  doc["targetGrindLevel"] = targetGrindLevel;
  doc["lastAction"] = lastAction;
  doc["scaleOK"] = scaleOK;
  doc["optocoupler"] = (digitalRead(OPTO_PIN) == HIGH);
  doc["waitingForStart"] = waitForStartSignal;  // NEU
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleGetConfig() {
  // Gibt aktuelle Konfiguration zur√ºck
  StaticJsonDocument<256> doc;
  doc["targetWeight"] = targetWeight;
  doc["targetGrindLevel"] = targetGrindLevel;
  doc["isGrinding"] = isGrinding;
  doc["currentWeight"] = currentWeight;
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleReset() {
  // Setzt alles zur√ºck (f√ºr Tests)
  stopGrinding();
  targetWeight = 18.0;
  targetGrindLevel = 5;
  waitForStartSignal = false;
  lastAction = "Zur√ºckgesetzt";
  
  server.send(200, "application/json", "{\"success\":true,\"message\":\"System zur√ºckgesetzt\"}");
}

void handleNotFound() {
  server.send(404, "text/plain", "404: Not Found");
}

// =====================
// SETUP
// =====================

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Serial.println("   KAFFEEM√úHLE STEUERUNG - ESP32 #1");
  Serial.println("   W√§gezelle & Optokoppler-Steuerung");
  Serial.println("   Version: 3-ESP-System");
  Serial.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
  
  // PC817 INITIALISIEREN
  pinMode(OPTO_PIN, OUTPUT);
  digitalWrite(OPTO_PIN, LOW); // Start mit Optokoppler AUS
  
  pinMode(TARE_BTN, INPUT_PULLUP);
  
  scaleOK = initScale();
  
  // WLAN konfigurieren
  WiFi.begin(ssid, password);
  
  // Statische IP setzen
  WiFi.config(IPAddress(192, 168, 4, 2),    // Feste IP f√ºr ESP32 #1
              IPAddress(192, 168, 4, 1),    // Gateway
              IPAddress(255, 255, 255, 0)); // Subnetz
  
  Serial.print("Verbinde mit WLAN ");
  while(WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\n‚úÖ WLAN verbunden");
  Serial.print("IP-Adresse: ");
  Serial.println(WiFi.localIP());
  Serial.print("Webserver (ESP32 #2): ");
  Serial.println("192.168.4.1");
  Serial.print("Mahlgrad (ESP32 #3): ");
  Serial.println("192.168.4.3");
  
  // Server-Endpoints
  server.on("/grind", handleGrind);        // Direkter Start mit Parametern
  server.on("/start", handleStart);        // Start mit gespeicherten Werten
  server.on("/stop", handleStop);          // Stoppt sofort
  server.on("/tare", handleTare);          // Tariert
  server.on("/setTarget", handleSetTarget); // Setzt nur Ziel (wartet auf Start)
  server.on("/status", handleStatus);      // Status abfragen
  server.on("/config", handleGetConfig);   // Konfiguration abfragen
  server.on("/reset", handleReset);        // Zur√ºcksetzen
  server.onNotFound(handleNotFound);
  
  server.begin();
  Serial.println("‚úÖ HTTP Server gestartet");
  
  Serial.println("\nBetriebsmodus: Getrennte Steuerung");
  Serial.println("1. ESP32 #2 setzt Ziel √ºber /setTarget");
  Serial.println("2. ESP32 #3 stellt Mahlgrad ein");
  Serial.println("3. ESP32 #2 startet √ºber /start");
  Serial.println("4. Automatischer Stop bei Erreichen des Gewichts");
  
  Serial.println("\nVerf√ºgbare Befehle:");
  Serial.println("  /setTarget?weight=18&level=5 - Setzt Ziel");
  Serial.println("  /start                      - Startet Mahlung");
  Serial.println("  /stop                       - Stoppt Mahlung");
  Serial.println("  /grind?weight=18&level=5    - Direkter Start");
  Serial.println("  /tare                       - Tariert W√§gezelle");
  Serial.println("  /status                     - Status abfragen");
  Serial.println("  /config                     - Konfiguration");
}

void loop() {
  server.handleClient();
  readScale();
  checkGrinding();
  
  // Tare-Button (lokaler Hardware-Button)
  static unsigned long lastTarePress = 0;
  if(digitalRead(TARE_BTN) == LOW && millis() - lastTarePress > 1000) {
    lastTarePress = millis();
    if(scaleOK) {
      scale.tare();
      currentWeight = 0;
      Serial.println("‚úÖ Manuell tariert");
      lastAction = "Manuell tariert";
    }
  }
  
  // Statusanzeige alle 30 Sekunden
  static unsigned long lastStatusPrint = 0;
  if(millis() - lastStatusPrint > 30000) {
    lastStatusPrint = millis();
    Serial.print("Status: ");
    if(isGrinding) {
      Serial.print("Mahlung aktiv - ");
      Serial.print(currentWeight, 1);
      Serial.print("g von ");
      Serial.print(targetWeight, 1);
      Serial.println("g");
    } else if(waitForStartSignal) {
      Serial.println("Bereit - warte auf Start (" + String(targetWeight, 1) + "g)");
    } else {
      Serial.println("Bereit");
    }
  }
  
  delay(10);
}
