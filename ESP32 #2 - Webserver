#include <WiFi.h>
#include <WebServer.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>

// =====================
// WLAN ACCESS POINT
// =====================
const char* apSSID = "Kaffeemuehle";
const char* apPassword = "12345678";

// =====================
// ZIEL-ESP32s
// =====================
const char* grinderIP = "192.168.4.2";      // ESP32 #1: W√§gezelle
const char* grindControllerIP = "192.168.4.3"; // ESP32 #3: Mahlgrad

// =====================
// WEB SERVER
// =====================
WebServer server(80);

// =====================
// KAFFEE REZEPTE
// =====================
struct Recipe {
  String name;
  float weight;
  int grindLevel;  // 1-10
  String description;
};

Recipe recipes[] = {
  {"Espresso", 18.0, 3, "Stark und aromatisch"},
  {"Doppelter Espresso", 36.0, 3, "Doppelte St√§rke"},
  {"Filterkaffee", 30.0, 7, "Mild und ausgewogen"},
  {"French Press", 45.0, 10, "Kr√§ftig und vollmundig"},
  {"T√ºrkischer Mocca", 12.0, 1, "Sehr fein und stark"},
  {"Cold Brew", 60.0, 9, "F√ºr kalten Kaffee"},
  {"Cappuccino", 18.0, 4, "Milchschaum-Kaffee"},
  {"Latte Macchiato", 22.0, 5, "Milchreich"}
};

const int recipeCount = 8;
int currentRecipeIndex = 0;

// =====================
// FUNKTIONEN F√úR ESP32-KOMMUNIKATION
// =====================

// Kommunikation mit ESP32 #1 (W√§gezelle)
bool sendToGrinder(String command, float value = 0, int level = 0) {
  HTTPClient http;
  String url;
  
  if (command == "TARE") {
    url = "http://" + String(grinderIP) + "/tare";
  } else if (command == "GRIND") {
    url = "http://" + String(grinderIP) + "/grind?weight=" + String(value, 1) + "&level=" + String(level);
  } else if (command == "STOP") {
    url = "http://" + String(grinderIP) + "/stop";
  } else if (command == "START") {
    url = "http://" + String(grinderIP) + "/start";
  } else if (command == "STATUS") {
    url = "http://" + String(grinderIP) + "/status";
  } else if (command == "SET_TARGET") {
    url = "http://" + String(grinderIP) + "/setTarget?weight=" + String(value, 1) + "&level=" + String(level);
  } else {
    return false;
  }
  
  Serial.print("Sende an Grinder (ESP32 #1): ");
  Serial.println(url);
  
  http.begin(url);
  http.setTimeout(5000);
  
  int httpCode = http.GET();
  bool success = (httpCode == 200);
  
  if (httpCode > 0) {
    String response = http.getString();
    Serial.print("Antwort Code: ");
    Serial.print(httpCode);
    Serial.print(", Antwort: ");
    Serial.println(response);
  } else {
    Serial.print("Fehler: ");
    Serial.println(http.errorToString(httpCode));
  }
  
  http.end();
  return success;
}

// Kommunikation mit ESP32 #3 (Mahlgrad)
bool sendToGrindController(String command, int level = 0) {
  HTTPClient http;
  String url;
  
  if (command == "SET_LEVEL") {
    url = "http://" + String(grindControllerIP) + "/setLevel?level=" + String(level);
  } else if (command == "STATUS") {
    url = "http://" + String(grindControllerIP) + "/status";
  } else if (command == "TEST") {
    url = "http://" + String(grindControllerIP) + "/test";
  } else {
    return false;
  }
  
  Serial.print("Sende an Mahlgrad-Steuerung (ESP32 #3): ");
  Serial.println(url);
  
  http.begin(url);
  http.setTimeout(3000);
  
  int httpCode = http.GET();
  bool success = (httpCode == 200);
  
  if (httpCode > 0) {
    String response = http.getString();
    Serial.print("Antwort: ");
    Serial.println(response);
  } else {
    Serial.print("Fehler ESP32 #3: ");
    Serial.println(http.errorToString(httpCode));
  }
  
  http.end();
  return success;
}

String getGrinderStatus() {
  HTTPClient http;
  String url = "http://" + String(grinderIP) + "/status";
  
  http.begin(url);
  http.setTimeout(3000);
  
  int httpCode = http.GET();
  String response = "{\"error\":\"Keine Verbindung\"}";
  
  if (httpCode == 200) {
    response = http.getString();
  }
  
  http.end();
  return response;
}

String getGrindControllerStatus() {
  HTTPClient http;
  String url = "http://" + String(grindControllerIP) + "/status";
  
  http.begin(url);
  http.setTimeout(3000);
  
  int httpCode = http.GET();
  String response = "{\"error\":\"Keine Verbindung\"}";
  
  if (httpCode == 200) {
    response = http.getString();
  }
  
  http.end();
  return response;
}

// =====================
// HTML WEB INTERFACE (gleich wie vorher)
// =====================

const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kaffeem√ºhle Steuerung</title>
  <style>
    /* CSS Code bleibt gleich wie in Ihrer Version */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #6f4e37 0%, #8b7355 100%);
      color: #333;
      min-height: 100vh;
      padding: 20px;
    }
    
    /* ... Rest des CSS bleibt gleich ... */
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>‚òï Intelligente Kaffeem√ºhle</h1>
      <div class="subtitle">Steuerung √ºber ESP32 WebInterface</div>
    </header>
    
    <div class="main-content">
      <!-- Linke Spalte: Rezepte -->
      <div class="card">
        <h2>Kaffee-Rezepte ausw√§hlen</h2>
        <div id="recipeMessage" class="message info">
          W√§hle ein Rezept aus und starte die Mahlung
        </div>
        
        <div class="recipe-grid" id="recipesContainer">
          <!-- Rezepte werden hier eingef√ºgt -->
        </div>
        
        <div class="button-group">
          <button class="btn btn-primary" onclick="startGrinding()" id="btnGrind">
            <span>‚öôÔ∏è</span> Mahlung starten
          </button>
          <button class="btn btn-secondary" onclick="tareScale()">
            <span>‚öñÔ∏è</span> Tarieren
          </button>
        </div>
        
        <button class="btn btn-danger" onclick="emergencyStop()" style="width:100%; margin-top:10px;">
          <span>‚õî</span> NOT-AUS (Stopp)
        </button>
      </div>
      
      <!-- Rechte Spalte: Status -->
      <div class="card">
        <h2>System Status</h2>
        
        <div class="status-box">
          <div class="status-item">
            <span class="status-label">Aktuelles Rezept:</span>
            <span class="status-value" id="currentRecipeName">-</span>
          </div>
          <div class="status-item">
            <span class="status-label">Zielgewicht:</span>
            <span class="status-value" id="targetWeight">0.0 g</span>
          </div>
          <div class="status-item">
            <span class="status-label">Mahlgrad:</span>
            <span class="status-value" id="grindLevel">-</span>
          </div>
          <div class="status-item">
            <span class="status-label">W√§gezellen-Gewicht:</span>
            <span class="status-value" id="currentWeight">0.0 g</span>
          </div>
          <div class="status-item">
            <span class="status-label">Mahlgrad Status:</span>
            <span class="status-value" id="grindControllerStatus">-</span>
          </div>
          <div class="status-item">
            <span class="status-label">System Status:</span>
            <span class="status-value" id="systemStatus">Verbinde...</span>
          </div>
          <div class="status-item">
            <span class="status-label">Letzte Aktion:</span>
            <span class="status-value" id="lastAction">-</span>
          </div>
        </div>
        
        <div id="statusMessage" class="message">
          <!-- Statusmeldungen erscheinen hier -->
        </div>
        
        <div class="button-group">
          <button class="btn btn-secondary" onclick="refreshStatus()">
            <span>üîÑ</span> Status aktualisieren
          </button>
          <button class="btn btn-secondary" onclick="testGrindController()">
            <span>üîß</span> Mahlgrad testen
          </button>
        </div>
      </div>
    </div>
    
    <div class="connection-info">
      Verbunden mit: <span class="ip-address" id="ipDisplay">192.168.4.1</span><br>
      Grinder ESP32: <span class="ip-address" id="grinderIP">192.168.4.2</span><br>
      Mahlgrad ESP32: <span class="ip-address" id="grindControllerIP">192.168.4.3</span>
    </div>
  </div>

  <script>
    let currentRecipeId = 0;
    let isGrinding = false;
    let currentWeight = 0;
    let targetWeight = 0;
    
    // Rezepte laden und anzeigen
    function loadRecipes() {
      fetch('/api/recipes')
        .then(response => response.json())
        .then(data => {
          const container = document.getElementById('recipesContainer');
          container.innerHTML = '';
          
          data.recipes.forEach((recipe, index) => {
            const card = document.createElement('div');
            card.className = 'recipe-card';
            if(index === currentRecipeId) {
              card.classList.add('selected');
            }
            
            card.innerHTML = `
              <div class="recipe-name">${recipe.name}</div>
              <div class="recipe-details">
                <span class="recipe-weight">${recipe.weight} g</span><br>
                Mahlgrad: ${recipe.grindLevel}/10
              </div>
              <div class="recipe-details" style="margin-top:5px; font-size:0.8em;">
                ${recipe.description}
              </div>
            `;
            
            card.onclick = () => selectRecipe(index);
            container.appendChild(card);
          });
          
          updateSelectedRecipeDisplay();
        })
        .catch(error => {
          showMessage('error', 'Fehler beim Laden der Rezepte');
        });
    }
    
    // Rezept ausw√§hlen
    function selectRecipe(id) {
      fetch('/api/selectRecipe?id=' + id)
        .then(response => response.json())
        .then(data => {
          if(data.success) {
            currentRecipeId = id;
            loadRecipes();
            
            // Setze Zielgewicht auf Grinder ESP32
            const recipe = data.recipe;
            targetWeight = recipe.weight;
            
            // Zuerst Mahlgrad einstellen
            fetch('/api/setGrindLevel?level=' + recipe.grindLevel)
              .then(response => response.json())
              .then(grindData => {
                if(grindData.success) {
                  showMessage('success', `"${recipe.name}" ausgew√§hlt - Mahlgrad ${recipe.grindLevel} eingestellt`);
                  document.getElementById('grindLevel').textContent = recipe.grindLevel + '/10';
                  
                  // Dann Zielgewicht setzen
                  return fetch('/api/setTarget?weight=' + recipe.weight);
                }
              })
              .then(response => response.json())
              .then(targetData => {
                if(targetData.success) {
                  document.getElementById('targetWeight').textContent = recipe.weight + ' g';
                  document.getElementById('currentRecipeName').textContent = recipe.name;
                }
              })
              .catch(error => {
                showMessage('warning', 'Rezept ausgew√§hlt, aber Mahlgrad konnte nicht eingestellt werden');
              });
          }
        })
        .catch(error => {
          showMessage('error', 'Fehler beim Ausw√§hlen des Rezepts');
        });
    }
    
    // Mahlung starten (jetzt mit Mahlgrad-Vorbereitung)
    function startGrinding() {
      if(isGrinding) {
        showMessage('error', 'Mahlung l√§uft bereits!');
        return;
      }
      
      document.getElementById('btnGrind').disabled = true;
      document.getElementById('systemStatus').textContent = 'Starte Mahlung...';
      document.getElementById('systemStatus').classList.add('grinding');
      
      // 1. Zuerst Mahlgrad sicherstellen
      fetch('/api/ensureGrindLevel')
        .then(response => response.json())
        .then(grindData => {
          if(grindData.success) {
            showMessage('info', 'Mahlgrad eingestellt, starte Mahlung...');
            
            // 2. Dann Mahlung starten
            return fetch('/api/startGrinding');
          } else {
            throw new Error('Mahlgrad konnte nicht eingestellt werden');
          }
        })
        .then(response => response.json())
        .then(data => {
          if(data.success) {
            isGrinding = true;
            showMessage('success', data.message);
            document.getElementById('lastAction').textContent = data.message;
            
            // Automatische Status-Updates starten
            startGrindingMonitor();
          } else {
            showMessage('error', data.message || 'Fehler beim Starten');
          }
        })
        .catch(error => {
          showMessage('error', 'Fehler: ' + error.message);
        })
        .finally(() => {
          document.getElementById('btnGrind').disabled = false;
        });
    }
    
    // √úberwacht den Mahlvorgang
    function startGrindingMonitor() {
      const monitorInterval = setInterval(() => {
        if(!isGrinding) {
          clearInterval(monitorInterval);
          return;
        }
        
        fetch('/api/status')
          .then(response => response.json())
          .then(data => {
            if(data.connected) {
              document.getElementById('currentWeight').textContent = data.weight + ' g';
              document.getElementById('systemStatus').textContent = 
                data.grinding ? 'Am Mahlen...' : 'Fertig';
              
              if(!data.grinding) {
                isGrinding = false;
                document.getElementById('systemStatus').classList.remove('grinding');
                showMessage('success', 'Mahlung abgeschlossen!');
                clearInterval(monitorInterval);
              }
            }
          });
      }, 1000);
    }
    
    // Tarieren
    function tareScale() {
      fetch('/api/tare')
        .then(response => response.json())
        .then(data => {
          if(data.success) {
            showMessage('success', 'W√§gezelle tariert');
            document.getElementById('lastAction').textContent = 'Tariert auf 0g';
            document.getElementById('currentWeight').textContent = '0.0 g';
          }
        })
        .catch(error => {
          showMessage('error', 'Tarieren fehlgeschlagen');
        });
    }
    
    // Not-Aus
    function emergencyStop() {
      fetch('/api/stop')
        .then(response => response.json())
        .then(data => {
          isGrinding = false;
          document.getElementById('systemStatus').textContent = 'Bereit';
          document.getElementById('systemStatus').classList.remove('grinding');
          showMessage('info', 'Mahlung gestoppt');
          document.getElementById('lastAction').textContent = 'Not-Stopp ausgel√∂st';
        });
    }
    
    // Mahlgrad testen
    function testGrindController() {
      fetch('/api/testGrindController')
        .then(response => response.json())
        .then(data => {
          if(data.success) {
            showMessage('success', 'Mahlgrad-Steuerung getestet');
          }
        });
    }
    
    // Status aktualisieren
    function refreshStatus() {
      // W√§gezellen-Status
      fetch('/api/status')
        .then(response => response.json())
        .then(data => {
          document.getElementById('currentWeight').textContent = data.weight + ' g';
          document.getElementById('systemStatus').textContent = 
            data.grinding ? 'Am Mahlen...' : 'Bereit';
          
          if(data.grinding) {
            document.getElementById('systemStatus').classList.add('grinding');
            isGrinding = true;
          } else {
            document.getElementById('systemStatus').classList.remove('grinding');
            isGrinding = false;
          }
          
          if(data.lastAction) {
            document.getElementById('lastAction').textContent = data.lastAction;
          }
        })
        .catch(error => {
          document.getElementById('systemStatus').textContent = 'Verbindungsfehler';
        });
      
      // Mahlgrad-Status
      fetch('/api/grindControllerStatus')
        .then(response => response.json())
        .then(data => {
          if(data.connected) {
            document.getElementById('grindControllerStatus').textContent = 
              `Mahlgrad ${data.currentLevel}/10`;
          } else {
            document.getElementById('grindControllerStatus').textContent = 'Nicht verbunden';
          }
        });
    }
    
    // Nachricht anzeigen
    function showMessage(type, text) {
      const messageDiv = document.getElementById('statusMessage');
      messageDiv.className = 'message ' + type;
      messageDiv.textContent = text;
      
      setTimeout(() => {
        if(messageDiv.textContent === text) {
          messageDiv.textContent = '';
          messageDiv.className = 'message';
        }
      }, 5000);
    }
    
    // Automatische Status-Updates
    setInterval(refreshStatus, 3000);
    
    // IP-Adressen anzeigen
    function displayIPs() {
      fetch('/api/network')
        .then(response => response.json())
        .then(data => {
          document.getElementById('ipDisplay').textContent = data.serverIP;
          document.getElementById('grinderIP').textContent = data.grinderIP;
          document.getElementById('grindControllerIP').textContent = data.grindControllerIP;
        });
    }
    
    // Initialisierung
    window.onload = function() {
      loadRecipes();
      refreshStatus();
      displayIPs();
    };
  </script>
</body>
</html>
)rawliteral";

// =====================
// API ENDPOINTS (ANGEPASST F√úR 3 ESP32s)
// =====================

void handleRoot() {
  server.send(200, "text/html", index_html);
}

void handleGetRecipes() {
  StaticJsonDocument<2048> doc;
  JsonArray recipesArray = doc.createNestedArray("recipes");
  
  for(int i = 0; i < recipeCount; i++) {
    JsonObject recipe = recipesArray.createNestedObject();
    recipe["id"] = i;
    recipe["name"] = recipes[i].name;
    recipe["weight"] = recipes[i].weight;
    recipe["grindLevel"] = recipes[i].grindLevel;
    recipe["description"] = recipes[i].description;
  }
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleSelectRecipe() {
  if(server.hasArg("id")) {
    int id = server.arg("id").toInt();
    if(id >= 0 && id < recipeCount) {
      currentRecipeIndex = id;
    }
  }
  
  StaticJsonDocument<256> doc;
  doc["success"] = true;
  doc["recipe"]["name"] = recipes[currentRecipeIndex].name;
  doc["recipe"]["weight"] = recipes[currentRecipeIndex].weight;
  doc["recipe"]["grindLevel"] = recipes[currentRecipeIndex].grindLevel;
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleSetGrindLevel() {
  if(server.hasArg("level")) {
    int level = server.arg("level").toInt();
    
    if(level >= 1 && level <= 10) {
      bool success = sendToGrindController("SET_LEVEL", level);
      
      StaticJsonDocument<256> doc;
      doc["success"] = success;
      doc["message"] = success ? 
        "Mahlgrad " + String(level) + " eingestellt" : 
        "Fehler beim Einstellen des Mahlgrads";
      doc["level"] = level;
      
      String response;
      serializeJson(doc, response);
      server.send(200, "application/json", response);
    } else {
      server.send(400, "application/json", "{\"success\":false,\"message\":\"Mahlgrad muss 1-10 sein\"}");
    }
  } else {
    server.send(400, "application/json", "{\"success\":false,\"message\":\"Level nicht angegeben\"}");
  }
}

void handleSetTarget() {
  if(server.hasArg("weight")) {
    float weight = server.arg("weight").toFloat();
    bool success = sendToGrinder("SET_TARGET", weight, recipes[currentRecipeIndex].grindLevel);
    
    StaticJsonDocument<256> doc;
    doc["success"] = success;
    doc["message"] = success ? 
      "Zielgewicht " + String(weight, 1) + "g gesetzt" : 
      "Fehler beim Setzen des Zielgewichts";
    
    String response;
    serializeJson(doc, response);
    server.send(200, "application/json", response);
  } else {
    server.send(400, "application/json", "{\"success\":false,\"message\":\"Gewicht nicht angegeben\"}");
  }
}

void handleStartGrinding() {
  // 1. Mahlgrad einstellen
  bool grindSuccess = sendToGrindController("SET_LEVEL", recipes[currentRecipeIndex].grindLevel);
  
  if(!grindSuccess) {
    Serial.println("‚ö†Ô∏è Warnung: Mahlgrad konnte nicht eingestellt werden");
    // Optional: Hier k√∂nnten Sie entscheiden abzubrechen
  }
  
  delay(1000); // Warten bis Mahlgrad eingestellt ist
  
  // 2. Mahlung starten
  bool grindStartSuccess = sendToGrinder("START");
  
  StaticJsonDocument<256> doc;
  doc["success"] = grindStartSuccess;
  
  if(grindStartSuccess) {
    doc["message"] = "Mahlung gestartet: " + recipes[currentRecipeIndex].name + 
                    " (" + String(recipes[currentRecipeIndex].weight, 1) + "g, Mahlgrad " + 
                    String(recipes[currentRecipeIndex].grindLevel) + ")";
  } else {
    doc["message"] = "Fehler: Grinder nicht erreichbar";
  }
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleEnsureGrindLevel() {
  // Stellt sicher dass der richtige Mahlgrad eingestellt ist
  bool success = sendToGrindController("SET_LEVEL", recipes[currentRecipeIndex].grindLevel);
  
  StaticJsonDocument<128> doc;
  doc["success"] = success;
  doc["message"] = success ? 
    "Mahlgrad sichergestellt" : 
    "Mahlgrad konnte nicht eingestellt werden";
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleTare() {
  bool success = sendToGrinder("TARE");
  
  StaticJsonDocument<128> doc;
  doc["success"] = success;
  doc["message"] = success ? "Getariert" : "Tarieren fehlgeschlagen";
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleStop() {
  bool success = sendToGrinder("STOP");
  
  StaticJsonDocument<128> doc;
  doc["success"] = success;
  doc["message"] = "Stop-Befehl gesendet";
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleTestGrindController() {
  bool success = sendToGrindController("TEST");
  
  StaticJsonDocument<128> doc;
  doc["success"] = success;
  doc["message"] = success ? "Test durchgef√ºhrt" : "Test fehlgeschlagen";
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleGetStatus() {
  String grinderStatus = getGrinderStatus();
  
  StaticJsonDocument<512> doc;
  DeserializationError error = deserializeJson(doc, grinderStatus);
  
  StaticJsonDocument<512> responseDoc;
  
  if(!error) {
    responseDoc["weight"] = doc["weight"].as<float>();
    responseDoc["grinding"] = doc["grinding"].as<bool>();
    responseDoc["lastAction"] = doc["lastAction"].as<String>();
    responseDoc["connected"] = true;
  } else {
    responseDoc["weight"] = 0.0;
    responseDoc["grinding"] = false;
    responseDoc["lastAction"] = "Keine Verbindung";
    responseDoc["connected"] = false;
  }
  
  String response;
  serializeJson(responseDoc, response);
  server.send(200, "application/json", response);
}

void handleGrindControllerStatus() {
  String grindControllerStatus = getGrindControllerStatus();
  
  StaticJsonDocument<512> doc;
  DeserializationError error = deserializeJson(doc, grindControllerStatus);
  
  StaticJsonDocument<512> responseDoc;
  
  if(!error) {
    responseDoc["currentLevel"] = doc["currentLevel"].as<int>();
    responseDoc["targetLevel"] = doc["targetLevel"].as<int>();
    responseDoc["isMoving"] = doc["isMoving"].as<bool>();
    responseDoc["connected"] = true;
  } else {
    responseDoc["currentLevel"] = 0;
    responseDoc["targetLevel"] = 0;
    responseDoc["isMoving"] = false;
    responseDoc["connected"] = false;
  }
  
  String response;
  serializeJson(responseDoc, response);
  server.send(200, "application/json", response);
}

void handleNetworkInfo() {
  StaticJsonDocument<256> doc;
  doc["serverIP"] = WiFi.softAPIP().toString();
  doc["grinderIP"] = grinderIP;
  doc["grindControllerIP"] = grindControllerIP;
  doc["ssid"] = apSSID;
  
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleNotFound() {
  server.send(404, "text/plain", "404: Not Found");
}

// =====================
// SETUP & LOOP
// =====================

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n=== ESP32 Kaffeem√ºhle WebServer (3-ESP-System) ===");
  Serial.println("Starte Access Point...");
  
  // Access Point starten
  WiFi.softAP(apSSID, apPassword);
  
  // Statische IP f√ºr Access Point konfigurieren
  WiFi.softAPConfig(IPAddress(192, 168, 4, 1), 
                    IPAddress(192, 168, 4, 1), 
                    IPAddress(255, 255, 255, 0));
  
  IPAddress IP = WiFi.softAPIP();
  Serial.print("Access Point IP: ");
  Serial.println(IP);
  Serial.print("SSID: ");
  Serial.println(apSSID);
  Serial.print("Grinder ESP32 (W√§gezelle): ");
  Serial.println(grinderIP);
  Serial.print("Mahlgrad ESP32: ");
  Serial.println(grindControllerIP);
  
  // API Endpoints definieren
  server.on("/", handleRoot);
  server.on("/api/recipes", handleGetRecipes);
  server.on("/api/selectRecipe", handleSelectRecipe);
  server.on("/api/setGrindLevel", handleSetGrindLevel);
  server.on("/api/setTarget", handleSetTarget);
  server.on("/api/startGrinding", handleStartGrinding);
  server.on("/api/ensureGrindLevel", handleEnsureGrindLevel);
  server.on("/api/tare", handleTare);
  server.on("/api/stop", handleStop);
  server.on("/api/testGrindController", handleTestGrindController);
  server.on("/api/status", handleGetStatus);
  server.on("/api/grindControllerStatus", handleGrindControllerStatus);
  server.on("/api/network", handleNetworkInfo);
  server.onNotFound(handleNotFound);
  
  // Server starten
  server.begin();
  Serial.println("‚úÖ HTTP Server gestartet");
  Serial.println("Verbinde dich mit dem WLAN: " + String(apSSID));
  Serial.println("√ñffne im Browser: http://" + IP.toString());
  Serial.println("\nSystem bereit f√ºr 3-ESP-Betrieb!");
}

void loop() {
  server.handleClient();
}
